"""This module provides the definitions for registering a GCC toolchain for C and C++.
"""

load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("@bazel_skylib//lib:paths.bzl", "paths")

def _gcc_toolchain_impl(rctx):
    absolute_toolchain_root = str(rctx.path("."))
    execroot = paths.normalize(paths.join(absolute_toolchain_root, "..", ".."))
    toolchain_root = paths.relativize(absolute_toolchain_root, execroot)

    rctx.download_and_extract(
        sha256 = rctx.attr.sha256,
        stripPrefix = rctx.attr.strip_prefix,
        url = rctx.attr.url,
    )

    target_arch = rctx.attr.target_arch
    if rctx.attr.binary_prefix:
        binary_prefix = rctx.attr.binary_prefix
    else:
        binary_prefix = target_arch

    tool_paths = _get_tool_paths(rctx, execroot, binary_prefix)

    generated_header = "GENERATED - This file was generated by the repository target @{}.".format(rctx.name)

    sysroot = ""
    if rctx.attr.sysroot:
        sysroot_build_label = Label("@{workspace}//{package}:BUILD.bazel".format(
            workspace = rctx.attr.sysroot.workspace_name,
            package = rctx.attr.sysroot.package,
        ))
        sysroot = paths.dirname(str(rctx.path(sysroot_build_label)))
        sysroot = paths.relativize(sysroot, execroot)

    # If the sysroot is absolute, it gets passed to other scripts that can introduce non-deterministic behaviour to the
    # system. E.g. rules_foreign_cc will render templates with the absolute path, producing cache misses on the remote
    # cache.
    if paths.is_absolute(sysroot):
        fail("sysroot ({}) must not be absolute".format(sysroot))

    cxx_builtin_include_directories = rctx.attr.includes
    for include in cxx_builtin_include_directories:
        if paths.is_absolute(include):
            fail("include ({}) must not be absolute".format(include))
        if not include.startswith("%sysroot%") and not include.startswith("%workspace%"):
            fail("include ({}) must be prefixed with %sysroot% or %workspace%".format(include))

    includes = [
        include.replace("%sysroot%", sysroot).replace("%workspace%", toolchain_root)
        for include in cxx_builtin_include_directories
    ]

    target_compatible_with = [
        str(Label(v.format(target_arch = target_arch)))
        for v in rctx.attr.target_compatible_with
    ]

    # The following glob matches all the cases:
    #   - aarch64-buildroot-linux-gnu
    #   - arm-buildroot-linux-gnueabihf
    #   - x86_64-buildroot-linux-gnu
    platform_directory_glob_pattern = "*-buildroot-linux-gnu*"

    substitutions = {
        "__bazel_gcc_toolchain_workspace_name__": rctx.attr.bazel_gcc_toolchain_workspace_name,
        "__binary_prefix__": binary_prefix,
        "__generated_header__": generated_header,
        "__platform_directory_glob_pattern__": platform_directory_glob_pattern,
        "__target_arch__": target_arch,
        "__target_compatible_with__": str(target_compatible_with),

        # Sysroot
        "__sysroot__": sysroot,
        "__sysroot_label__": str(rctx.attr.sysroot) if rctx.attr.sysroot else "",

        # Includes
        "__cxx_builtin_include_directories__": str(cxx_builtin_include_directories),

        # Flags
        "__extra_cflags__": str(rctx.attr.extra_cflags),
        "__extra_cxxflags__": str(rctx.attr.extra_cxxflags),
        "__extra_ldflags__": _format_flags(sysroot, toolchain_root, rctx.attr.extra_ldflags),
        "__includes__": str(includes),

        # Tool paths
        "__tool_paths__": str(tool_paths),
    }
    rctx.template("BUILD.bazel", rctx.attr._toolchain_build_template, substitutions = substitutions)

def _get_tool_paths(rctx, execroot, binary_prefix):
    relative_tool_paths = {
        "ar": paths.relativize(str(rctx.path("bin/{}-linux-ar".format(binary_prefix))), execroot),
        "as": paths.relativize(str(rctx.path("bin/{}-linux-as".format(binary_prefix))), execroot),
        "cpp": paths.relativize(str(rctx.path("bin/{}-linux-cpp".format(binary_prefix))), execroot),
        "gcc": paths.relativize(str(rctx.path("bin/{}-linux-gcc".format(binary_prefix))), execroot),
        "gcov": paths.relativize(str(rctx.path("bin/{}-linux-gcov".format(binary_prefix))), execroot),
        "ld": paths.relativize(str(rctx.path("bin/{}-linux-ld".format(binary_prefix))), execroot),
        "nm": paths.relativize(str(rctx.path("bin/{}-linux-nm".format(binary_prefix))), execroot),
        "objcopy": paths.relativize(str(rctx.path("bin/{}-linux-objcopy".format(binary_prefix))), execroot),
        "objdump": paths.relativize(str(rctx.path("bin/{}-linux-objdump".format(binary_prefix))), execroot),
        "strip": paths.relativize(str(rctx.path("bin/{}-linux-strip".format(binary_prefix))), execroot),
    }

    path_env = ":".join([
        "${{EXECROOT}}/{}".format(paths.dirname(tool_path))
        for name, tool_path in relative_tool_paths.items()
    ])

    tool_paths = {}
    for name, tool_path in relative_tool_paths.items():
        wrapped_tool_path = paths.join("bin", name)
        rctx.template(
            wrapped_tool_path,
            rctx.attr._wrapper_sh_template,
            substitutions = {
                "__PATH__": path_env,
                "__binary__": tool_path,
            },
            executable = True,
        )
        tool_paths[name] = wrapped_tool_path
    return tool_paths

def _format_flags(sysroot, toolchain_root, flags):
    return str([
        flag.replace("%sysroot%", sysroot).replace("%workspace%", toolchain_root)
        for flag in flags
    ])

_DOWNLOAD_TOOLCHAIN_ATTRS = {
    "sha256": attr.string(
        doc = "The SHA256 integrity hash for the interpreter tarball.",
        mandatory = True,
    ),
    "strip_prefix": attr.string(
        doc = "The prefix to strip from the extracted tarball.",
        mandatory = True,
    ),
    "url": attr.string(
        doc = "The URL of the interpreter tarball.",
        mandatory = True,
    ),
}

_FEATURE_ATTRS = {
    "bazel_gcc_toolchain_workspace_name": attr.string(
        doc = "The name given to the repository when imported bazel_gcc_toolchain.",
        default = "bazel_gcc_toolchain",
    ),
    "binary_prefix": attr.string(
        doc = "An explicit prefix used by each binary in bin/. Defaults to `<target_arch>`.",
        mandatory = False,
    ),
    "extra_cflags": attr.string_list(
        doc = "Extra flags for compiling C.",
        default = [],
    ),
    "extra_cxxflags": attr.string_list(
        doc = "Extra flags for compiling C++.",
        default = [],
    ),
    "extra_ldflags": attr.string_list(
        doc = "Extra flags for linking." +
            " %sysroot% is rendered to the sysroot path." +
            " %workspace% is rendered to the toolchain root path." +
            " See https://github.com/bazelbuild/bazel/blob/a48e246e/src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainProviderHelper.java#L234-L254.",
        default = [],
    ),
    "includes": attr.string_list(
        doc = "Extra includes for compiling C and C++." +
            " %sysroot% is rendered to the sysroot path." +
            " %workspace% is rendered to the toolchain root path." +
            " See https://github.com/bazelbuild/bazel/blob/a48e246e/src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainProviderHelper.java#L234-L254.",
        default = [],
    ),
    "sysroot": attr.label(
        doc = "A sysroot to be used as the logical build root.",
        mandatory = True,
    ),
    "target_arch": attr.string(
        doc = "The target architecture this toolchain produces. E.g. x86_64.",
        mandatory = True,
    ),
    "target_compatible_with": attr.string_list(
        default = [
            "@platforms//os:linux",
            "@platforms//cpu:{target_arch}",
        ],
        doc = "contraint_values passed to target_compatible_with of the toolchain. {target_arch} is rendered to the target_arch attribute value.",
        mandatory = False,
    ),
}

_PRIVATE_ATTRS = {
    "_build_bootlin_template": attr.label(
        default = Label("//toolchain:BUILD.bootlin.tpl"),
    ),
    "_toolchain_build_template": attr.label(
        default = Label("//toolchain:toolchain.BUILD.bazel.tpl"),
    ),
    "_wrapper_sh_template": attr.label(
        default = Label("//toolchain:wrapper.sh.tpl"),
    ),
}

gcc_toolchain = repository_rule(
    _gcc_toolchain_impl,
    attrs = dicts.add(
        _DOWNLOAD_TOOLCHAIN_ATTRS,
        _FEATURE_ATTRS,
        _PRIVATE_ATTRS,
    ),
)

def gcc_register_toolchain(name, **kwargs):
    """Declares a `gcc_toolchain` and calls `register_toolchain` for it.

    Args:
        name: The name passed to `gcc_toolchain`.
        **kwargs: The extra arguments passed to `gcc_toolchain`. See `gcc_toolchain` for more info.
    """
    gcc_toolchain(
        name = name,
        **kwargs
    )

    native.register_toolchains("@{}//:toolchain".format(name))
