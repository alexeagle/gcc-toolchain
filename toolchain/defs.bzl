"""This module provides the definitions for registering a GCC toolchain for C and C++.
"""

load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("@bazel_skylib//lib:paths.bzl", "paths")
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load("//sysroot:flags.bzl", "cflags", "cxxflags", "ldflags", "includes")

def _gcc_toolchain_impl(rctx):
    absolute_toolchain_root = str(rctx.path("."))
    execroot = paths.normalize(paths.join(absolute_toolchain_root, "..", ".."))
    toolchain_root = paths.relativize(absolute_toolchain_root, execroot)

    rctx.download_and_extract(
        sha256 = rctx.attr.sha256,
        stripPrefix = rctx.attr.strip_prefix,
        url = rctx.attr.url,
    )

    target_arch = rctx.attr.target_arch
    if rctx.attr.binary_prefix:
        binary_prefix = rctx.attr.binary_prefix
    else:
        binary_prefix = target_arch

    tool_paths = _get_tool_paths(rctx, execroot, binary_prefix)

    generated_header = "GENERATED - This file was generated by the repository target @{}.".format(rctx.name)

    sysroot = ""
    if rctx.attr.sysroot:
        sysroot_build_label = Label("@{workspace}//{package}:BUILD.bazel".format(
            workspace = rctx.attr.sysroot.workspace_name,
            package = rctx.attr.sysroot.package,
        ))
        sysroot = paths.dirname(str(rctx.path(sysroot_build_label)))
        sysroot = paths.relativize(sysroot, execroot)

    # If the sysroot is absolute, it gets passed to other scripts that can introduce non-deterministic behaviour to the
    # system. E.g. rules_foreign_cc will render templates with the absolute path, producing cache misses on the remote
    # cache.
    if paths.is_absolute(sysroot):
        fail("sysroot ({}) must not be absolute".format(sysroot))

    cxx_builtin_include_directories = rctx.attr.includes
    for include in cxx_builtin_include_directories:
        if paths.is_absolute(include):
            fail("include ({}) must not be absolute".format(include))
        if not include.startswith("%sysroot%") and not include.startswith("%workspace%"):
            fail("include ({}) must be prefixed with %sysroot% or %workspace%".format(include))

    includes = [
        include.replace("%sysroot%", sysroot).replace("%workspace%", toolchain_root)
        for include in cxx_builtin_include_directories
    ]

    target_compatible_with = [
        str(Label(v.format(target_arch = target_arch)))
        for v in rctx.attr.target_compatible_with
    ]

    # The following glob matches all the cases:
    #   - aarch64-buildroot-linux-gnu
    #   - arm-buildroot-linux-gnueabihf
    #   - x86_64-buildroot-linux-gnu
    platform_directory_glob_pattern = "*-buildroot-linux-gnu*"

    substitutions = {
        "__binary_prefix__": binary_prefix,
        "__gcc_toolchain_workspace_name__": rctx.attr.gcc_toolchain_workspace_name,
        "__generated_header__": generated_header,
        "__platform_directory_glob_pattern__": platform_directory_glob_pattern,
        "__target_arch__": target_arch,
        "__target_compatible_with__": str(target_compatible_with),

        # Sysroot
        "__sysroot__": sysroot,
        "__sysroot_label__": str(rctx.attr.sysroot) if rctx.attr.sysroot else "",

        # Includes
        "__cxx_builtin_include_directories__": str(cxx_builtin_include_directories),

        # Flags
        "__extra_cflags__": str(rctx.attr.extra_cflags),
        "__extra_cxxflags__": str(rctx.attr.extra_cxxflags),
        "__extra_ldflags__": _format_flags(sysroot, toolchain_root, rctx.attr.extra_ldflags),
        "__includes__": str(includes),

        # Tool paths
        "__tool_paths__": str(tool_paths),
    }
    rctx.template("BUILD.bazel", rctx.attr._toolchain_build_template, substitutions = substitutions)

def _get_tool_paths(rctx, execroot, binary_prefix):
    relative_tool_paths = {
        "ar": paths.relativize(str(rctx.path("bin/{}-linux-ar".format(binary_prefix))), execroot),
        "as": paths.relativize(str(rctx.path("bin/{}-linux-as".format(binary_prefix))), execroot),
        "cpp": paths.relativize(str(rctx.path("bin/{}-linux-cpp".format(binary_prefix))), execroot),
        "gcc": paths.relativize(str(rctx.path("bin/{}-linux-gcc".format(binary_prefix))), execroot),
        "gcov": paths.relativize(str(rctx.path("bin/{}-linux-gcov".format(binary_prefix))), execroot),
        "ld": paths.relativize(str(rctx.path("bin/{}-linux-ld".format(binary_prefix))), execroot),
        "nm": paths.relativize(str(rctx.path("bin/{}-linux-nm".format(binary_prefix))), execroot),
        "objcopy": paths.relativize(str(rctx.path("bin/{}-linux-objcopy".format(binary_prefix))), execroot),
        "objdump": paths.relativize(str(rctx.path("bin/{}-linux-objdump".format(binary_prefix))), execroot),
        "strip": paths.relativize(str(rctx.path("bin/{}-linux-strip".format(binary_prefix))), execroot),
    }

    path_env = ":".join([
        "${{EXECROOT}}/{}".format(paths.dirname(tool_path))
        for name, tool_path in relative_tool_paths.items()
    ])

    tool_paths = {}
    for name, tool_path in relative_tool_paths.items():
        wrapped_tool_path = paths.join("bin", name)
        rctx.template(
            wrapped_tool_path,
            rctx.attr._wrapper_sh_template,
            substitutions = {
                "__PATH__": path_env,
                "__binary__": tool_path,
            },
            executable = True,
        )
        tool_paths[name] = wrapped_tool_path
    return tool_paths

def _format_flags(sysroot, toolchain_root, flags):
    return str([
        flag.replace("%sysroot%", sysroot).replace("%workspace%", toolchain_root)
        for flag in flags
    ])

_DOWNLOAD_TOOLCHAIN_ATTRS = {
    "sha256": attr.string(
        doc = "The SHA256 integrity hash for the interpreter tarball.",
        mandatory = True,
    ),
    "strip_prefix": attr.string(
        doc = "The prefix to strip from the extracted tarball.",
        mandatory = True,
    ),
    "url": attr.string(
        doc = "The URL of the interpreter tarball.",
        mandatory = True,
    ),
}

_FEATURE_ATTRS = {
    "binary_prefix": attr.string(
        doc = "An explicit prefix used by each binary in bin/. Defaults to `<target_arch>`.",
        mandatory = False,
    ),
    "gcc_toolchain_workspace_name": attr.string(
        doc = "The name given to the gcc-toolchain repository, if the default was not used.",
        default = "aspect_gcc_toolchain",
    ),
    "extra_cflags": attr.string_list(
        doc = "Extra flags for compiling C.",
        default = [],
    ),
    "extra_cxxflags": attr.string_list(
        doc = "Extra flags for compiling C++.",
        default = [],
    ),
    "extra_ldflags": attr.string_list(
        doc = "Extra flags for linking." +
            " %sysroot% is rendered to the sysroot path." +
            " %workspace% is rendered to the toolchain root path." +
            " See https://github.com/bazelbuild/bazel/blob/a48e246e/src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainProviderHelper.java#L234-L254.",
        default = [],
    ),
    "includes": attr.string_list(
        doc = "Extra includes for compiling C and C++." +
            " %sysroot% is rendered to the sysroot path." +
            " %workspace% is rendered to the toolchain root path." +
            " See https://github.com/bazelbuild/bazel/blob/a48e246e/src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainProviderHelper.java#L234-L254.",
        default = [],
    ),
    "sysroot": attr.label(
        doc = "A sysroot to be used as the logical build root.",
        mandatory = True,
    ),
    "target_arch": attr.string(
        doc = "The target architecture this toolchain produces. E.g. x86_64.",
        mandatory = True,
    ),
    "target_compatible_with": attr.string_list(
        default = [
            "@platforms//os:linux",
            "@platforms//cpu:{target_arch}",
        ],
        doc = "contraint_values passed to target_compatible_with of the toolchain. {target_arch} is rendered to the target_arch attribute value.",
        mandatory = False,
    ),
}

_PRIVATE_ATTRS = {
    "_build_bootlin_template": attr.label(
        default = Label("//toolchain:BUILD.bootlin.tpl"),
    ),
    "_toolchain_build_template": attr.label(
        default = Label("//toolchain:toolchain.BUILD.bazel.tpl"),
    ),
    "_wrapper_sh_template": attr.label(
        default = Label("//toolchain:wrapper.sh.tpl"),
    ),
}

gcc_toolchain = repository_rule(
    _gcc_toolchain_impl,
    attrs = dicts.add(
        _DOWNLOAD_TOOLCHAIN_ATTRS,
        _FEATURE_ATTRS,
        _PRIVATE_ATTRS,
    ),
)

def gcc_register_toolchain(
    name,
    target_arch,
    **kwargs
):
    """Declares a `gcc_toolchain` and calls `register_toolchain` for it.

    Args:
        name: The name passed to `gcc_toolchain`.
        target_arch: The target architecture of the toolchain.
        **kwargs: The extra arguments passed to `gcc_toolchain`. See `gcc_toolchain` for more info.
    """
    sysroot = kwargs.pop("sysroot", None)
    if not sysroot:
        http_archive(
            name = "sysroot_{}".format(target_arch),
            build_file_content = _SYSROOT_BUILD_FILE_CONTENT,
            sha256 = _SYSROOTS[target_arch].sha256,
            url = _SYSROOTS[target_arch].url,
        )

    gcc_toolchain(
        name = name,
        binary_prefix = kwargs.pop("binary_prefix", "arm" if target_arch == ARCHS.armv7 else None),
        extra_cflags = kwargs.pop("extra_cflags", cflags),
        extra_cxxflags = kwargs.pop("extra_cxxflags", cxxflags),
        extra_ldflags = kwargs.pop("extra_ldflags", ldflags(target_arch, _GCC_VERSION)),
        includes = kwargs.pop("includes", includes(target_arch, _GCC_VERSION)),
        sha256 = kwargs.pop("sha256", _TOOLCHAINS[target_arch].sha256),
        strip_prefix = kwargs.pop("strip_prefix", _TOOLCHAINS[target_arch].strip_prefix),
        sysroot = kwargs.pop("sysroot", "@sysroot_{}//:sysroot".format(target_arch)),
        target_arch = target_arch,
        url = kwargs.pop("url", _TOOLCHAINS[target_arch].url),
        **kwargs
    )

    native.register_toolchains("@{}//:toolchain".format(name))

ARCHS = struct(
    aarch64 = "aarch64",
    armv7 = "armv7",
    x86_64 = "x86_64",
)

_SYSROOTS = {
    "aarch64": struct(
        sha256 = "8ccddd7ca9cd188fbfb06bf29fc5dccc213e5b80591f44e3f84c38e5ad0bb419",
        url = "https://github.com/aspect-build/gcc-toolchain/releases/download/0.1.0/sysroot-aarch64.tar.xz",
    ),
    "armv7": struct(
        sha256 = "a3941793e74fd21b1dfc067c7e96d4e6e246914f9050eaf44abb0ebc91121227",
        url = "https://github.com/aspect-build/gcc-toolchain/releases/download/0.1.0/sysroot-armv7.tar.xz",
    ),
    "x86_64": struct(
        sha256 = "a5b0f5515684b16fb564b935f4b7ee28feda8ded966e26be7c67db71c6148493",
        url = "https://github.com/aspect-build/gcc-toolchain/releases/download/0.1.0/sysroot-x86_64.tar.xz",
    ),
}

_TOOLCHAINS = {
    "aarch64": struct(
        sha256 = "dec070196608124fa14c3f192364c5b5b057d7f34651ad58ebb8fc87959c97f7",
        strip_prefix = "aarch64--glibc--stable-2021.11-1",
        url = "https://toolchains.bootlin.com/downloads/releases/toolchains/aarch64/tarballs/aarch64--glibc--stable-2021.11-1.tar.bz2",
    ),
    "armv7": struct(
        sha256 = "6d10f356811429f1bddc23a174932c35127ab6c6f3b738b768f0c29c3bf92f10",
        strip_prefix = "armv7-eabihf--glibc--stable-2021.11-1",
        url = "https://toolchains.bootlin.com/downloads/releases/toolchains/armv7-eabihf/tarballs/armv7-eabihf--glibc--stable-2021.11-1.tar.bz2",
    ),
    "x86_64": struct(
        sha256 = "6fe812add925493ea0841365f1fb7ca17fd9224bab61a731063f7f12f3a621b0",
        strip_prefix = "x86-64--glibc--stable-2021.11-5",
        url = "https://toolchains.bootlin.com/downloads/releases/toolchains/x86-64/tarballs/x86-64--glibc--stable-2021.11-5.tar.bz2",
    ),
}

_GCC_VERSION = "10.3.0"

_SYSROOT_BUILD_FILE_CONTENT = """\
filegroup(
    name = "sysroot",
    srcs = glob(["**"]),
    visibility = ["//visibility:public"],
)

cc_library(
    name = "libstdcxx",
    srcs = glob(
        include = ["**/libstdc++.so*"],
        exclude = ["**/*.py"],
    ),
    visibility = ["//visibility:public"],
)

[cc_library(
    name = "lib{}".format(san),
    srcs = glob(["**/lib{}.so*".format(san)]),
    visibility = ["//visibility:public"],
) for san in ["asan", "tsan", "ubsan"]]
"""
