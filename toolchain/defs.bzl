"""This module provides the definitions for registering a GCC toolchain for C and C++.
"""

load("@bazel_skylib//lib:collections.bzl", "collections")
load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("@bazel_skylib//lib:paths.bzl", "paths")
load("//toolchain:unix_cc_configure.bzl", "get_cxx_include_directories", "get_no_canonical_prefixes_opt")

def _gcc_toolchain_impl(rctx):
    absolute_toolchain_root = str(rctx.path("."))
    execroot = paths.normalize(paths.join(absolute_toolchain_root, "..", ".."))
    toolchain_root = paths.relativize(absolute_toolchain_root, execroot)

    rctx.download_and_extract(
        sha256 = rctx.attr.sha256,
        stripPrefix = rctx.attr.strip_prefix,
        url = rctx.attr.url,
    )

    target_arch = rctx.attr.target_arch
    if rctx.attr.binary_prefix:
        binary_prefix = rctx.attr.binary_prefix
    else:
        binary_prefix = target_arch

    (tool_paths, real_tool_paths) = _get_tool_paths(rctx, execroot, binary_prefix)

    generated_header = "GENERATED - This file was generated by the repository target @{}.".format(rctx.name)

    if rctx.attr.platform_directory:
        platform_directory = rctx.attr.platform_directory
    else:
        platform_directory = "{}-buildroot-linux-gnu".format(target_arch)

    if not rctx.path(platform_directory):
        fail("'platform_directory' does not exist")

    sysroot = ""
    if rctx.attr.sysroot:
        sysroot_build_label = Label("@{workspace}//{package}:BUILD.bazel".format(
            workspace = rctx.attr.sysroot.workspace_name,
            package = rctx.attr.sysroot.package,
        ))
        sysroot = paths.dirname(str(rctx.path(sysroot_build_label)))
        sysroot = paths.relativize(sysroot, execroot)

    # If the sysroot is absolute, it gets passed to other scripts that can introduce non-deterministic behaviour to the
    # system. E.g. rules_foreign_cc will render templates with the absolute path, producing cache misses on the remote
    # cache.
    if paths.is_absolute(sysroot):
        fail("sysroot ({}) must not be absolute".format(sysroot))

    cxx_builtin_include_directories = _get_cxx_builtin_include_directories(
        rctx,
        execroot,
        real_tool_paths["gcc"],
        sysroot,
        toolchain_root,
        rctx.attr.extra_cflags,
        rctx.attr.extra_cxxflags,
        rctx.attr.extra_includes,
    )

    for include in cxx_builtin_include_directories:
        if paths.is_absolute(include):
            fail("include ({}) must not be absolute".format(include))
        if not include.startswith("%sysroot%") and not include.startswith("%workspace%"):
            fail("include ({}) must be prefixed with %sysroot% or %workspace%".format(include))

    extra_includes = [
        include.replace("%sysroot%", sysroot).replace("%workspace%", toolchain_root)
        for include in cxx_builtin_include_directories
    ]

    target_compatible_with = [
        str(Label(v.format(target_arch = target_arch)))
        for v in rctx.attr.target_compatible_with
    ]

    substitutions = {
        "__bazel_gcc_toolchain_workspace_name__": rctx.attr.bazel_gcc_toolchain_workspace_name,
        "__binary_prefix__": binary_prefix,
        "__generated_header__": generated_header,
        "__platform_directory__": platform_directory,
        "__target_arch__": target_arch,
        "__target_compatible_with__": str(target_compatible_with),

        # Sysroot
        "__sysroot__": sysroot,
        "__sysroot_label__": str(rctx.attr.sysroot) if rctx.attr.sysroot else "",

        # Includes
        "__cxx_builtin_include_directories__": str(cxx_builtin_include_directories),

        # Flags
        "__extra_cflags__": _format_flags(sysroot, toolchain_root, rctx.attr.extra_cflags),
        "__extra_cxxflags__": _format_flags(sysroot, toolchain_root, rctx.attr.extra_cxxflags),
        "__extra_includes__": str(extra_includes),
        "__extra_ldflags__": _format_flags(sysroot, toolchain_root, rctx.attr.extra_ldflags),

        # Tool paths
        "__tool_paths__": str(tool_paths),
    }
    rctx.template("BUILD.bazel", rctx.attr._toolchain_build_template, substitutions = substitutions)

def _get_tool_paths(rctx, execroot, binary_prefix):
    real_tool_paths = {
        "ar": str(rctx.path("bin/{}-linux-ar".format(binary_prefix))),
        "as": str(rctx.path("bin/{}-linux-as".format(binary_prefix))),
        "cpp": str(rctx.path("bin/{}-linux-cpp".format(binary_prefix))),
        "gcc": str(rctx.path("bin/{}-linux-gcc".format(binary_prefix))),
        "gcov": str(rctx.path("bin/{}-linux-gcov".format(binary_prefix))),
        "ld": str(rctx.path("bin/{}-linux-ld".format(binary_prefix))),
        "nm": str(rctx.path("bin/{}-linux-nm".format(binary_prefix))),
        "objcopy": str(rctx.path("bin/{}-linux-objcopy".format(binary_prefix))),
        "objdump": str(rctx.path("bin/{}-linux-objdump".format(binary_prefix))),
        "strip": str(rctx.path("bin/{}-linux-strip".format(binary_prefix))),
    }

    tool_paths = {}
    for name, real_path in real_tool_paths.items():
        wrapped_tool_path = paths.join("bin", name)
        rctx.template(
            wrapped_tool_path,
            rctx.attr._wrapper_sh_template,
            substitutions = {"__binary__": paths.relativize(real_path, execroot)},
            executable = True,
        )
        tool_paths[name] = wrapped_tool_path
    return (tool_paths, real_tool_paths)

def _format_flags(sysroot, toolchain_root, flags):
    return str([
        flag.format(
            sysroot = sysroot,
            toolchain_root = toolchain_root,
        )
        for flag in flags
    ])

def _get_cxx_builtin_include_directories(
    rctx,
    execroot,
    gcc,
    sysroot,
    toolchain_root,
    extra_cflags,
    extra_cxxflags,
    extra_includes,
):
    absolute_sysroot = paths.join(execroot, sysroot)
    absolute_toolchain_root = paths.join(execroot, toolchain_root)
    extra_cflags = [
        extra_cflag.format(
            sysroot = absolute_sysroot,
            toolchain_root = absolute_toolchain_root,
        )
        for extra_cflag in extra_cflags
    ]
    extra_cxxflags = [
        extra_cxxflag.format(
            sysroot = absolute_sysroot,
            toolchain_root = absolute_toolchain_root,
        )
        for extra_cxxflag in extra_cxxflags
    ]
    extra_includes = [
        "-isystem" + extra_include.format(
            sysroot = absolute_sysroot,
            toolchain_root = absolute_toolchain_root,
        )
        for extra_include in extra_includes
    ]
    cxx_builtin_include_directories = []
    if sysroot:
        cxx_builtin_include_directories.extend(get_cxx_include_directories(
            rctx,
            gcc,
            "-xc",
            extra_cflags + ["--sysroot", absolute_sysroot] + extra_includes,
        ))
        cxx_builtin_include_directories.extend(get_cxx_include_directories(
            rctx,
            gcc,
            "-xc++",
            extra_cxxflags + ["--sysroot", absolute_sysroot] + extra_includes,
        ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc",
        extra_cflags + extra_includes,
    ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc++",
        extra_cxxflags + extra_includes,
    ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc",
    ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc++",
    ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc",
        get_no_canonical_prefixes_opt(rctx, gcc),
    ))
    cxx_builtin_include_directories.extend(get_cxx_include_directories(
        rctx,
        gcc,
        "-xc++",
        get_no_canonical_prefixes_opt(rctx, gcc),
    ))
    # If the path is not absolute, it means it is coming from the toolchain, so we make it absolute
    # so we can normalize them in the same pipeline below.
    cxx_builtin_include_directories = [
        include if paths.is_absolute(include) else paths.join(absolute_toolchain_root, include)
        for include in cxx_builtin_include_directories
    ]
    # We replace the absolute paths with %sysroot% and %workspace% depending on the prefix.
    # See https://github.com/bazelbuild/bazel/blob/a48e246e/src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainProviderHelper.java#L234-L254.
    cxx_builtin_include_directories = [
        "%sysroot%" + include.removeprefix(absolute_sysroot) if include.startswith(absolute_sysroot) else include
        for include in cxx_builtin_include_directories
    ]
    cxx_builtin_include_directories = [
        "%workspace%" + include.removeprefix(absolute_toolchain_root) if include.startswith(absolute_toolchain_root) else include
        for include in cxx_builtin_include_directories
    ]
    return collections.uniq(cxx_builtin_include_directories)

_DOWNLOAD_TOOLCHAIN_ATTRS = {
    "sha256": attr.string(
        doc = "The SHA256 integrity hash for the interpreter tarball.",
        mandatory = True,
    ),
    "strip_prefix": attr.string(
        doc = "The prefix to strip from the extracted tarball.",
        mandatory = True,
    ),
    "url": attr.string(
        doc = "The URL of the interpreter tarball.",
        mandatory = True,
    ),
}

_FEATURE_ATTRS = {
    "bazel_gcc_toolchain_workspace_name": attr.string(
        doc = "The name give to the repository when imported bazel_gcc_toolchain.",
        default = "bazel_gcc_toolchain",
    ),
    "binary_prefix": attr.string(
        doc = "An explicit prefix used by each binary in bin/. Defaults to `<target_arch>`.",
        mandatory = False,
    ),
    "builtin_sysroot_path": attr.string(
        doc = "An explicit sysroot path inside the tarball. Defaults to `<platform_directory>/sysroot`.",
        mandatory = False,
    ),
    "extra_includes": attr.string_list(
        doc = "Extra includes for compiling C and C++." +
            " {sysroot} is rendered to the sysroot path." +
            " {toolchain_root} is rendered to the toolchain root path.",
        default = [],
    ),
    "extra_cflags": attr.string_list(
        doc = "Extra flags for compiling C." +
            " {sysroot} is rendered to the sysroot path." +
            " {toolchain_root} is rendered to the toolchain root path.",
        default = [],
    ),
    "extra_cxxflags": attr.string_list(
        doc = "Extra flags for compiling C++." +
            " {sysroot} is rendered to the sysroot path." +
            " {toolchain_root} is rendered to the toolchain root path.",
        default = [],
    ),
    "extra_ldflags": attr.string_list(
        doc = "Extra flags for linking." +
            " {sysroot} is rendered to the sysroot path." +
            " {toolchain_root} is rendered to the toolchain root path.",
        default = [],
    ),
    "platform_directory": attr.string(
        doc = "An explicit directory containing the target platform extra directories. Defaults to `<target_arch>-buildroot-linux-gnu`.",
        mandatory = False,
    ),
    "sysroot": attr.label(
        doc = "A sysroot to be used as the logical build root.",
        mandatory = True,
    ),
    "target_arch": attr.string(
        doc = "The target architecture this toolchain produces. E.g. x86_64.",
        mandatory = True,
    ),
    "target_compatible_with": attr.string_list(
        default = [
            "@platforms//os:linux",
            "@platforms//cpu:{target_arch}",
        ],
        doc = "contraint_values passed to target_compatible_with of the toolchain. {target_arch} is rendered to the target_arch attribute value.",
        mandatory = False,
    ),
}

_PRIVATE_ATTRS = {
    "_build_bootlin_template": attr.label(
        default = Label("//toolchain:BUILD.bootlin.tpl"),
    ),
    "_toolchain_build_template": attr.label(
        default = Label("//toolchain:toolchain.BUILD.bazel.tpl"),
    ),
    "_wrapper_sh_template": attr.label(
        default = Label("//toolchain:wrapper.sh.tpl"),
    ),
}

gcc_toolchain = repository_rule(
    _gcc_toolchain_impl,
    attrs = dicts.add(
        _DOWNLOAD_TOOLCHAIN_ATTRS,
        _FEATURE_ATTRS,
        _PRIVATE_ATTRS,
    ),
)

def gcc_register_toolchain(name, **kwargs):
    """Declares a `gcc_toolchain` and calls `register_toolchain` for it.

    Args:
        name: The name passed to `gcc_toolchain`.
        **kwargs: The extra arguments passed to `gcc_toolchain`. See `gcc_toolchain` for more info.
    """
    gcc_toolchain(
        name = name,
        **kwargs
    )

    native.register_toolchains("@{}//:toolchain".format(name))
